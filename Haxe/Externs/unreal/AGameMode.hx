/**
   * 
   * WARNING! This file was autogenerated by: 
   *  _   _ _____     ___   _   _ __   __ 
   * | | | |  ___|   /   | | | | |\ \ / / 
   * | | | | |__    / /| | | |_| | \ V /  
   * | | | |  __|  / /_| | |  _  | /   \  
   * | |_| | |___  \___  | | | | |/ /^\ \ 
   *  \___/\____/      |_/ \_| |_/\/   \/ 
   * 
   * This file was autogenerated by UE4HaxeExternGenerator using UHT definitions. It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
   * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;


/**
  GameMode is a subclass of GameModeBase that behaves like a multiplayer match-based game.
  It has default behavior for picking spawn points and match state.
  If you want a simpler base, inherit from GameModeBase instead.
**/
@:glueCppIncludes("GameFramework/GameMode.h")
@:uextern extern class AGameMode extends unreal.AGameModeBase {
  
  /**
    Returns the current match state, this is an accessor to protect the state machine flow
  **/
  @:thisConst @:final public function GetMatchState() : unreal.FName;
  
  /**
    Returns true if the match state is InProgress or other gameplay state
  **/
  @:thisConst public function IsMatchInProgress() : Bool;
  
  /**
    Returns true if the match state is WaitingPostMatch or later
  **/
  @:thisConst public function HasMatchEnded() : Bool;
  
  /**
    Transition from WaitingToStart to InProgress. You can call this manually, will also get called if ReadyToStartMatch returns true
  **/
  public function StartMatch() : Void;
  
  /**
    Transition from InProgress to WaitingPostMatch. You can call this manually, will also get called if ReadyToEndMatch returns true
  **/
  public function EndMatch() : Void;
  
  /**
    Restart the game, by default travel to the current map
  **/
  public function RestartGame() : Void;
  
  /**
    Report that a match has failed due to unrecoverable error
  **/
  public function AbortMatch() : Void;
  
  /**
    Time a playerstate will stick around in an inactive state after a player logout
  **/
  private var InactivePlayerStateLifeSpan : unreal.Float32;
  
  /**
    PlayerStates of players who have disconnected from the server (saved in case they reconnect)
  **/
  public var InactivePlayerArray : unreal.TArray<unreal.APlayerState>;
  
  /**
    Contains strings describing localized game agnostic messages.
  **/
  public var EngineMessageClass : unreal.TSubclassOf<unreal.ULocalMessage>;
  
  /**
    Number of players that are still traveling from a previous map
  **/
  public var NumTravellingPlayers : unreal.Int32;
  
  /**
    Minimum time before player can respawn after dying.
  **/
  public var MinRespawnDelay : unreal.Float32;
  
  /**
    number of non-human players (AI controlled but participating as a player).
  **/
  public var NumBots : unreal.Int32;
  
  /**
    Current number of human players.
  **/
  public var NumPlayers : unreal.Int32;
  
  /**
    Current number of spectators.
  **/
  public var NumSpectators : unreal.Int32;
  
  /**
    Whether the game should immediately start when the first player logs in. Affects the default behavior of ReadyToStartMatch
  **/
  public var bDelayedStart : Bool;
  
  /**
    What match state we are currently in
  **/
  private var MatchState : unreal.FName;
  
  /**
    Implementable event to respond to match state changes
  **/
  private function K2_OnSetMatchState(NewState : unreal.FName) : Void;
  
  /**
    @return True if ready to Start Match. Games should override this
  **/
  private function ReadyToStartMatch() : Bool;
  
  /**
    @return true if ready to End Match. Games should override this
  **/
  private function ReadyToEndMatch() : Bool;
  
  /**
    Exec command to broadcast a string to all players
  **/
  public function Say(Msg : unreal.FString) : Void;
  
  /**
    Alters the synthetic bandwidth limit for a running game.
  **/
  public function SetBandwidthLimit(AsyncIOBandwidthLimit : unreal.Float32) : Void;
  
}
